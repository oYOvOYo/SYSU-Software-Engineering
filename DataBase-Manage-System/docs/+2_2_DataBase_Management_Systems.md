---
layout: post
date: 2017/06/25
title: 数据库管理系统
tags:
    - Code
    - DateBase
    - Todo
categories:
    - Reading
---

本文将概述数据库管理系统的主要内容，目的在于使读者看完以后能对数据库有比较具体的了解，关于实际应用的方面的知识将详细介绍。本文中间会有较多枯燥（无用）的概念知识，如果觉得不感兴趣大可跳过。

# 数据库管理系统

> 请知悉：本文对应教材
> Database Management Systems, 3rd Ed.
> 影印版：《数据库管理系统原理与设计》（第3版）

> 本文仅供概览知识，对于诸多细节还是建议读者查阅相关书籍，多实践。

## 序言部分

> 什么是数据库？
> 我们为什么要学习数据库？

顾名思义，数据库就是存放数据的仓库（集合），数据库这个名称似乎很容易在生活中听到，听起来有几分高大，实际上也是这样。由于数据库的诸多优越性，数据库在存取数据的时候是经常用到的。对于我们而言。首先是要学会使用，次而是了解数据库背后的组成和原理，就像任何一个大的软件一样，诸多细节（不管是原理上的还是编写上的）都是值得学习和借鉴的。

## 数据库系统概述

> 本节将对数据库进行一个概览，进一步解释数据库的优越性和组成部分。

从我学习编程开始，“大数据”就是一个热门词汇。毫无疑问，数据是及其重要的，我们说，计算机是计算数据的机器，数据因为其解释/表现方式而丰富多彩。而数据库则是专门设计来存放数据的仓库，与此对应的数据库管理系统（DBMS），则是用来配套实现数据存取的配套软件。

在了解关于数据库的具体的细节和使用之前，我们先来回顾一下数据库的历史发展，限于篇幅和作者本人的知识水平，没法将整个数据库的发展历史和背后的道理及有趣的事件分享给大家，这里只总结下历史的关键性轨迹，从最开始的网状数据库，到层次数据模型，再到风靡全球的关系型数据库，以及最近兴起的非关系型数据库，和数据库通过web的访问和操作，计算机在发展，数据库也当然在发展，余下篇幅的算法/解决方案都是前人智慧和心血的结晶。

为什么不使用文件系统？这可能是很多人会问的一个问题，大多数人的数据（比如图片，音乐，文档）都是通过操作系统所提供的文件管理系统，比如文件浏览器来管理和访问的。毫无疑问，文件系统很强大，也很重要，但是在有些使用场景，文件系统并不能满足需求。在对特定数据的存取上，文件系统要求我们具体化到具体的文件（夹），这样有好也有坏，在访问的方式，访问的速度，支持的操作等等方面上，数据库管理系统都比操作系统具有太多的优越性。

具体来说，使用数据库的优点有（1）数据独立性，数据独立于数据表达和储存细节。（2）高效的数据存取。（3）数据符合完整性约束（这里先理解成数据的限制），数据的安全性也会得到保障。（4）专人负责的数据管理。（5）并发储存和故障恢复。（6）在应用开发中使用可以减少开发时间。

> 在接下来很长一段文本，本文都有点纸上谈兵的感觉，但是最基础的了解也还是必须的，了解这些纸面上的原理将有益于日后的实际操作。

> 实践操作将在下文提及。

那么数据具体是怎么存放的呢？最开始我们会抛开储存的细节（虽然很重要，但是到需要注意的时候我们再注意。），使用一定的结构来描述数据，这样的结构的集合我们称为数据模型，今天大多数的数据库管理系统都是基于关系数据模型的（虽然非关系型数据库近几年崛起势头也很强），在最开始构建数据库的时候，大多数都会使用语义数据模型，一个广泛使用的语义数据模型是实体-关系（ER）模型，

接下来我们将重点关注关系模型，关系模型的核心也就是关系，而关系也就是具体记录的集合（比如具体记录是一个表格的行，而一个关系也就是这张表）。我们用模式来代表基于数据模型的数据描述方式，比如关系数据模型的模式，就需要说明关系的名字，关系中字段的名字和字段的类型。有些记录需要满足一定的条件，我们叫做完整性约束。

在构建具体的数据库系统时，我们把数据库分成三层，自上而下分别是外模式/概念模式/物理模式。外模式也就是为不同用户定制的的数据存取模式，概念模式也就是以数据模型来描述储存的数据，我们用数据定义语言（DDL）来描述外模式和概念模式。物理模式则专注于储存。之前我们说过的数据独立性也就是通过这几层抽象，使得数据的结构和储存方式发生变化时，应用程序的使用不受影响，数据独立性又分为逻辑数据独立性/物理数据独立性。

对于数据库中数据的提问称为查询，数据库提供了专门的语言来支持查询，也就是数据查询语言，其他的查询方式还有关系代数和关系演算。我们接下来都会涉及到，通俗的来讲，查询语言用户使用数据库的方法，大部分人学习使用数据库也就是学习使用查询语言。

由于数据库一般需要支持并发，我们需要足够的技术手段来解决操作的冲突问题，这里我们将操作的基本单位称为事务，事务具有原子性和强制执行性，同时通过加锁/解锁来避免冲突，当系统崩溃时，我们根据事务的日志来回退/重新执行事务。

讲到这里，我们介绍了数据库的一些细节和诸多专业术语，接下来我们来说明数据库管理系统的具体结构。

数据库管理系统接受的命令是SQL查询语句，不管发送语句的是本地客户端，还是各种服务端。数据库管理系统通过（分析器/优化器/计划执行器/操作求解器）来执行每条语句，再往下则是涉及到物理模式，也就是由事务管理器/锁管理器和恢复管理器负责的文件存取+缓存管理+磁盘空间管理，对于具体的数据库，一般有数据文件和索引文件，具体每个部分所涉及到的具体内容我们会日后再详细说明。

## 实体联系模型

> 实体-联系模型允许我们利用对象和对象间的联系去描述显示的数据，具体的设计流程可以先从分许需求，设计概念数据库，再设计逻辑数据库（就是将ER模式转化为关系数据库模式），本节的主要内容也就是这些。

首先我们先来看看一些术语，实体是指客观世界的一个对象，实体聚合被称为实体集，实体通过一组属性来描述，每个属性可以有自己的值域（前文所提到的完整性约束），对于每个实体集合，我们用码来代表最少能唯一确定每个实体的一组属性，当有多个候选码的时候，我们可以指定一个主码，联系是多个实体的一种关联，多个相似的联系在一起叫联系集，联系集也可以有自己的描述性属性。参与一个联系的实体可以来自一个联系集。

ER模型也就是实体-联系模型，对一个实体，唯一确定的在关系中出现一次，我们称之为码约束。如果关系中的实体A都要有有一个实体B，那么这就是参与约束，其中A是完全的，B是部分的。如果一个联系集中实体集是全部参入的，那么两者之间就用粗线连接。

对于没有专门的码的实体集，我们称其为弱实体集，它可以用它的一些属性和其他实体的主码结合起来形成唯一标识，我们称之为识别属主，识别属主必须和弱势体集参与一个一对多的联系集中，而且弱势体集在联系集中必须是全部参与的。弱实体的这个属性也就是部分码。

我们可以将一个类（实体集）细化为子类。覆盖约束是指子类的实体包含超类的全部实体，交迭约束是指子类中有交集。

聚合也就是将一个联系集参与到另一联系集中，使用聚合还是三元联系可以用完整性约束来指导的。

在将ER模型转化成概念数据库的时候我们会面临，选择实体还是属性？选择实体还是联系？选择聚合还是三元关系？具体来说是有一定取舍方法的，建议根据具体情况再具体而言。

## 关系模型

> 在学习了前述基础知识以后，我们将于本章正式开始学习关系模型的实际使用，使用SQL查询语言，在正式开始实践以前建议还是先装一个数据库软件，具体是什么大概没太大所谓，也可以配套装一个可视化软件，暂且推荐Mysql，如果是用SQLite的话，可能需要手动开启外键约束，具体可以参考SQLite的官方文档，SQLite的可视化可以使用SQLiteStudio。

之前我们已经说过，在关系型数据库中，是通过关系和来描述数据的，关系又包括关系模式和关系实例。关系实例就是一张表，而关系模式则是每个字段（列的名称）和每个字段的属性域。表格中的列/行的数目分别被成为度/基。

接下来我们开始正式接触SQL语句，增/删/改查的实例分别如下：
```sql
CREATE TABLE Students (sid CHAR(20), 
                       gpa REAL)

DELETE 
FROM TABLE Students S
WHERE S.sid = "15331111"

UPDATE Students S
SET S.gpa = S.gpa + 1
WHERE S.sid = "15331111"


INSERT
INTO TABLE Students (sid, gpa)
VALUES              ("15331111", 3.2)

```
其他关于SQL查询语言的基本知识，有的会在接下来的内容中涉及到，不过还是推荐写特定的SQL时常备一个参考，有什么不清楚的就具体去查。

之前我们有提到过完整性约束，如果一个表中有某个属性的值都不相同，那么就构成一个码约束，（其实这样就可以用该码唯一的确定一个记录），当某个表中有属性和其他表中的属性有关联的时候，我们希望在更新该值的时候同步更新在其他表中的这个值（反向应该也是可行的），这就是外码约束，码约束和外码约束的实例如下：
```sql
CREATE TABLE Students (sid CHAR(20), 
                       gpa REAL，
                       PRIMARY KEY (sid))

CREATE TABLE Homeworks (wid CHAR(10),
                        sid CHAR(20),
                        PRIMARY KEY (wid)
                        FOREIGN KEY (sid) REFERENCES Students
                                    ON DELETE CASCADE
                                    ON UPDATE NO ACTION)

```
当然我们可以制定更为一般的约束，关于约束的强制执行也很有意思，比如上面的示例，CASADE是说如果删除指向的记录时，自己也被删除，NO ACTION则是说违反约束的操作将拒绝执行。

SQL是一门查询语言，关于各种高级查询操作我们会在接下来的内容中慢慢涉及。

在之前的学习中，我们已经学习了建立ER模型来描述数据的方法，我们可以更加进一步将实体集映射到关系表，将联系集也映射到关系表（加上外码约束），当然，带有各种约束的关系我们也是可以转化的。

在有些时候，我们可能想要把特定的查询结果也看成一个关系表，但是不直接把它存在数据库中，而是在需要的时候根据特定算法计算出来，举例来说:
```sql
CREATE TABLE Students (sid CHAR(20), 
                       gpa REAL，
                       PRIMARY KEY (sid))

CREATE TABLE Homeworks (wid CHAR(10),
                        sid CHAR(20),
                        PRIMARY KEY (wid)
                        FOREIGN KEY (sid) REFERENCES Students)

CREATE VIEW Some-Students (sid, wid)
       AS SELECT S.name H.wid
          FROM Students S, Homework H
          WHERE S.gpa > 3 and H.sid = S.sid
```
对于视图的更新/删除，读者可以自行查找相关文章学习。这里不再赘述。

## 关系代数和演算
> 本节将继续描述描述查询的方法，关系代数是由基本的操作符集合而成，关系演算则有点像关系和集合的操作，这一节基本上都是理论知识，将会为后续学习做铺垫。

关系代数基本操作：选择，投影，集合操作（并， 差， 叉积）。组合操作：交，重命名，连接，除

关系演算基本形式：{ S | P(S) }，原子公式：A ∈ Rel / A.a op B.b / A.a op CONSTANT，递归的可表示为或/且/非/ => / 任意 / 存在

## SQL：查询，约束，触发器
> 我们说说的SQL语言包括（1）数据操作语言（DML）增/删/改/查。（2）数据定义语言（DDL）对表和视图的创建/修改/删除。（3）触发器和高级完整性约束。（4）其他（好像用不上所以就不仔细说了）。本节将对SQL语言的使用有一个深入的介绍。

SQL的查询的基本形式如下
```
SELECT [DISTINCT] Select-List // 保留的列
FROM From-List // 叉积
WHERE Qualification // 选择条件
```
我们可以在概念上这么理解执行过程，先计算差积，然后引用限制条件过滤，最后去掉不需要的列（可能还需要去掉重复的项），但实际上的执行为了执行速度会有很多优化。

在选择条件中，我们可以使用基本的逻辑式，也可以使用一些内置的函数进行简单计算，关于排序，SQL支持对字符集的整序概念，用户可以自行制定哪个字符比较小，对于模式匹配则可以使用LIKE操作符和通配符%。

对于SQL查询的结果，我们可以使用UNION/INTERSECT/EXPECT进一步操作，也支持嵌套查询，比如
```sql
SELECT FROM S.gpa
FROM Students.S
WHERE S.sid in ( SELECT H.sid
                 FROM Homeworks H
                 WHERE H.wid = "00001")
```
除去IN操作符，还有NOT IN / EXISTS，也可以使用集合比较操作，比如 > ALL (...) 的意思就是比其中任何一个都大，与ALL对应的还有ANY表示存在


除了以上提到的特性，SQL还支持对结果的初步计算汇总，我们称为聚合，一些常见的聚合操作符比如COUNT() / SUM() / AVG() / MAX() / MIN()等等，一个简单的示例如下：
```sql
SELECT COUNT(*)
FROM Students
```
像GROUP BY / HAVING 等语句这里不再仔细讨论，根据实际需求选择使用学习就好，

关于空值的一些逻辑操作符合逻辑短路的特性，具体的细节不再说明。

关于复杂完整性约束/断言/触发器等等也将略去。

## 储存数据：磁盘与文件
> 本节及以后部分将从下至上，讨论底层的储存系统，为以后的查询成本的计算做基础知识准备。

计算有分层的储存体系结构，同时使用缓存来加快速度，数据库文件一般放置在持久储存设备，磁盘上，磁盘的基础构造比如盘面/柱面/扇区，这里不在赘述，我们还需要知道磁盘的存取时间是由寻道时间/旋转延迟/传输时间共同决定的。

数据库关系系统的最底层是磁盘空间管理器，它给上层提供一些基本操作比如以文件页为单位的增/删/改/查命令，我们再使用缓存区管理器将磁盘空间管理器映射到内存中去，磁盘页被映射到缓冲池中的某一帧，同时提供根据缓冲区的替换策略（比如最少使用替换策略）的读取/删除操作/预读取等等。

记录是如何组成成文件？我们先实现一个可以驻留多个页的集合的记录文件，比如使用堆文件，使用页链表/页目录。对于具体每个页，我们放入单条记录，根据记录的定长，决定记录在页的位置。


## 储存与索引概述

通常我们将一个表抽象为一个记录文件，记录文件支持添加删除记录等基本操作。

在磁盘上组织数据记录有多种方式，比如说索引，索引使得我们可以有效的检索满足索引搜索码上的那些字段。我们用记录项来指代储存在索引文件中的记录，数据项中除了自身的标识，还可以额外储存真正的数据项，或者数据项的主码，或者是一个数据记录的列表。

当数据记录的顺序和数据项的实际顺序相同时，我们称之为聚簇索引，反之我们称之为非聚簇索引，聚簇性在范围搜索时具有很大影响，当然我们可以有多个索引，主次之分。

具体的索引项可以采用hash或者tree来实现，一般来说hash索引比较适合等值检索，聚簇的tree索引适合范围检索。

接下来我们分析几个基本的文件模型，来分析一些基本的操作时候的代价模型，B为block数目，R为每个block里面的记录数目，D为单block I/O 开销

![](/img/markdown/DBMS.jpg)

具体的分析读者可以自行推论验证。

## 树结构/哈希结构索引
树索引这里介绍两种，ISAM是一个静态索引结构，在文件不频繁修改的时候很有效，B+树是一个能适应文件变化的动态结构。通用的操作是从根节点开始根据索引文件确定数据项在数据文件的位置。插入在必要的时候增加溢出页。B+树如果在插入的时候可能造成分裂，在删除的时候可以和兄弟节点重分布数据项，或者直接和兄弟节点合并。

基于哈希的索引更加适用于等值检索，这里介绍静态哈希，扩展哈希模式和线性哈希模式。静态哈希和ISAM一样，在溢出过多的时候效率低下，可扩展哈希通过维护一个全局深度（D位标识码）和局部深度，当局部深度等于全局深度的时候，我们分裂该桶，重分布数据项，并增加全局深度。线性hash也是一种动态hash技术，当创建一个新的溢出页触发分裂的时候，我们按照顺序分裂一次桶，当结束一轮循环时我们需要增加hash结果的位数。线性hash不适用于数据分布偏斜的情况。

## 查询求解概述
通常来说，数据库系统会维护一个目录，其中记录一些像基数，大小，不同索引值个数等等信息的目录，目录实际上也存储表里面，我们可以用目录来参考一些操作的大概代价。

对于数据库的操作可以用操作符来描述，操作符的求解过程可以使用索引，迭代（扫描恰好包含查询域的索引的所有数据项），划分（使用排序或者哈希来依据特定排序码分块）来优化。

和取范式（CNF）是由值与属性的比较组合而成，访问路径就是从表中获取元祖的方法。我们分析具体操作，讨论最合适的访问路径。

选择可以使用索引，或者直接全部扫描一遍。
投影很容易办到，但是如果要求无重复我们就需要对属性进行划分，使用排序可能需要2-3次对表的扫描，如果恰好有对应得索引，那么我们可以只对索引的数据项进行排序。
连接作为代价较高的操作已经有多种实现，比如排序归并连接，索引嵌套连接。
其他操作，比如通常通过排序来实现的分组，类比投影删除重复的集合操作，使用临时计数器计数的聚集，这里都不在详细讨论。

查询优化就是通过分析器分析查询，使用计划生产器生成可能的执行计划，代价估计程序使用目录来估算代价，从中找出代价较小的交给执行器执行。一般的优化套路是下推选择和使用索引。

左深计划就是链接节点的左孩子是外部表，右孩子是内部表的查询计划，优化器通常采用动态编程的方法搜索所有左深计划，左深计划也使全流水线计划（所有连接可以使用流水线求解）有了可能。

## 外排序

当排序的大小达到主存无法容纳的时候我们就需要使用外排序算法，外排序算法致力于减少磁盘访问的次数。

两路归并排序算法只用三个主存页，读写开销为2N（log2（N）+ 1）。
外归并排序算法使用B个主存页，读写开销为2N（log（B - 1）（N））+ N / B 。
使用替换内存算法可以使第一轮输出的有序文件大小从B到2B。

B个缓冲页，b页的缓冲区块，块IO技术每次归并F= B/b - 1个有序段，处理遍数为（1 + log（F）（N2）），N2为第一次扫描后的有序端个数。

双缓冲可以有效降低查询的响应时间

当然如果我们恰好有查询码上的索引，我们可以使用B+树来排序，聚簇索引的话顺序读入所有记录就好，非聚簇索引就不一定划得来了。

## 关系操作求解

1. 选择操作
    1. 无索引未排序，扫描一遍
    2. 无索引排序，二分查找
    3. B+书索引，聚簇索引扫描索引，非聚簇索引运气不好还不如扫描
    3. Hash排序，等价选择，一到两个I/O
对于一般的选择操作我们试图将其变成通过‘且’连接的和取范式（CNF）形式，只有合取就扫描或者利用索引，如果含有析取，当前大多数数据库都不能有效的处理含析取的查询条件。
2. 投影，重点是去重
    1. 排序去重，参考之前的外归并排序相关复杂度。
    2. 哈希去重，主要是划分和消除重复元祖，插入的时候判断是否重复，M（读入）+ 2T（投影后元组页数）
3. 连接
    1. 嵌套循环连接算法
    2. 块嵌套循环连接算法
    3. 索引嵌套循环连接算法
    4. 排序归并连接算法
    5. 哈希连接
4. 集合操作
    1. 并和差，排序，排序归并去重
    2. 并和差，哈希，创表查重
5. 聚焦操作
    1. 扫描整个元组
    2. GROUNP BY，排序

## 典型的关系查询优化器
SQL查询语句=》分块=》代数表达式=》估算执行计划开销=》选最便宜的。
有些操作的左右操作表可以交换位置，类似的等价变化。
要枚举出所有查询计划。
典型的启发式优化，下移选择。

> 以上部分可能会涉及到具体的开销计算，需要记牢公式。

## 物理数据库设计和调整
回顾一下之前的数据库设计流程，然后主要就是建索引。

考虑最重要的查询，最好的执行计划，额外的索引是否有用等因素。

## 模式求精与范式
> 今天实在听不懂老师上课讲的内容了，于是去查了一下本节标题，遂发现本来很简单的事情，不知道为什么被讲的这么复杂。

在我们之前的课程中有讲过设计数据库，对于具体的一个数据库模式，我们希望它冗杂程度尽可能低，冗杂会引起储存/更新/插入/删除时的一些异常行为，对于数据冗杂，我们认为是由于属性之间存在某些函数依赖造成的，我们可以通过关系模式分解来解决冗杂的问题。（虽然也可能引起新的问题，比如丢失属性的有损分解和丢失依赖关系。

接着上面的话题，我们认为一个好的关系应该是尽可能少的数据冗杂，不会发生上述提到的异常，且分解后有无损连接/保持依赖等特性。

函数依赖（FD）也是一种完整性约束，是属性间的一种制约关系，它要求一个关系模式中的所有关系模式都满足约束条件，一般来说函数依赖也是属于语义范畴，只能根据数据语义来确定函数依赖，码约束就是一种特殊的函数依赖。

平凡函数依赖是指推出自己子集，部分函数依赖是指自己子集就可以推导过去，部分函数依赖就会引起之前我们说的那些异常。函数依赖同时也是可以传递的。也可能会引起异常。

函数依赖集是函数依赖的集合，函数依赖集所蕴含的所有函数依赖所组成的集合称为其闭包，我们可以使用Armstrong公理和公理的推论来计算闭包。（自反律/增补律/传递律 =》 合并律/分解律/伪传递律），在判断一个给定的函数依赖是否在闭包中时，我们只需要计算在依赖集中由A函数确定的所有属性的集合A+就可以。严重函数A-》B是否B在A+中就可以。（如果恰好A+包含了所有属性还会得到超码/候选码相关的问题）

上面我们提到的无损连接的判断方法是F+包涵（R1∩R2=》R1）（R1∩R2=》R2）（R1，R2是分解后的关系）充要条件就是两个分解的公共属性包含任何一个子关系的码。保持依赖分解当且仅当F1∪F2=F+

根据上面提到的函数依赖理论，我们可以将关系模式划分，1NF是每个属性对应的值域都是不可再分的，2NF是非主属性（不在候选码中）完全函数依赖于候选码，2NF消除了部分依赖但还有传递依赖，3NF就是非主属性都直接依赖于候选码，层层递推到BCNF，要求每一个非平凡函数依赖都包含候选码。

BCNF分解方法就是抽出存在的非平凡函数依赖A-》B建个R1，和剩下的属性集合R2，继续分R2直到满足BCNF（是无损分解但不一定保持依赖分解）

最后我们来点个题，就是关于数据库模式求精，也就是运用函数依赖理论/多值依赖理论等对已有的关系模式进行结构调整，分解，合并和优化。具体来说的步骤是确定函数依赖，确定所属范式，模式分解，模式合并。

## 事务管理

本节我们来具体看下数据库中对事务的管理，嗯作为本文章的最后一节收个尾巴。

事务的特性：原子性，一致性，隔离性，持久性。

DBMS内的事务也就是一格操作系列或者队列，那么不同事务之间有一个先后或者交叉上问题，完全调度是指调度中每个事务都有中止或提交操作，穿行调度是指事务之间没有交叉，可串行化是指该可以以某种调度方式达到串行调度一样的结果。

事务的交叉执行会引起一些异常，比如读未提交的数据，不可重复的读，重写未提交的数据等等。为了应对这些问题，我们有加锁机制，严格的2PL（两阶段加锁）是指：（1）事务在操作前需要先申请锁（2）事务结束后，会释放所有的锁。加锁会带来如死锁/效率低下的等待等问题。我们可以降低事务的并发程度和锁的严格程度来解决这些问题。

这里讲一个比较特殊的问题被称为幻影问题，比如你想查询所有分值为5的学生，这时候你需要先对现在分值为5的学生的上个锁，此时如果有一个事务又插入了一格分值为5的新的学生，你查询的结果就不确定，这个时候我们可以对整个表上锁，或者对分值为5这个索引上锁。

崩溃恢复涉及到一些概念比如偷帧（不写回）和强制写页（效率低下），利用原子性实现回滚。

## 并发控制

冲突等价：冲突的操作的次序在调度中的次序相同，冲突可串行化是指某个调度冲突等价于某个串行调度，是可串行化的充分非必要条件。

使用串行化图（优先图）来查看冲突问题，严格的2PL的变种两阶段加锁是指第二阶段的定义变为：一旦事务开始释放锁，就不能在申请锁。

观测等价是指：两个调度中的读/写的值相等，执行的写操作次数相等，观测可串行化是指
调度观测等价于某个串行调度。是可串行化的更加一般的条件。

申请锁可以用升级/降级的方法。判断死锁是优先图中存在回路。现实中可以使用超时机制来检测。

## 崩溃恢复

ARIES算法：
1. 分析：识别（修改了但是还没有写回的）脏页和崩溃时的事务。
2. 重做：从某个合适的点开始从重复所有操作，将数据库恢复到崩溃时的状态。
3. 反做：取消没有提交的事务操作。

## 结束

本文到此正式结束，有点越写越没有动力写的感觉，总体来说，更像是写给自己看的东西，呀明天就要挂数据库了，有点慌张。



